# 11.4 객체 통째로 넘기기

_Preserve Whole Object_

## 개요

Before

```python
low = a_room.days_temp_range.low
high = a_room.days_temp_range.high

if a_plan.within_range(low, high):
    ...
```

After

```python
if a_plan.within_range(a_room.days_temp_range):
    ...
```

## 배경

하나의 레코드[^1]에서 값 두어개를 가져와 인수로 넘기는 것 대신 레코드를 통째로 넘기고 함수 본문에서 필요한걸 쓰도록 작성하는게 낫다

레코드를 통째로 넘기면 변화에 대응하기 쉽다. 
함수가 레코드로부터 더 많은 데이터를 사용하도록 바뀌어도 매개변수 목록은 수정할 필요가 없다.
매개변수가 짧으면 함수를 이해하기도 쉬워진다.
한편, 레코드에 담긴 데이터의 일부를 받는 함수가 여러개면 그 함수에는 같은 데이터를 쓰는 부분이 있을 것이고, 그 로직은 중복될 가능성이 높다.
레코드를 통째로 넘기면 이런 중복도 없앨 수 있다.

함수가 레코드 자체에 의존하는 상황을 원하지 않으면 이 리팩터링은 알맞은 선택이 아니다.
레코드와 함수가 서로 다른 모듈에 속한 상황이면 특히 더 그렇다.

어떤 객체에서 값 몇 개를 얻고 그 값들로만 무언가를 하는 로직이 있다면 그 로직을 객체 안으로 집어넣어야 함을 알려주는 악취로 봐야한다.
객체를 통째로 넘기기는 매개변수 객체 만들기(6.8절) 후 적용하면 더욱 좋다. 데이터 더미를 하나의 객체로 묶고 그걸 인수로 주란 의미다.
한편, 한 객체가 제공하는 기능 중 항상 똑같은 일부만을 쓰는 코드가 많다면, 그 기능만 따로 묶어서 클래스로 추출(7.5)할 수도 있다.

다른 객체의 메소드를 호출하며, 호출하는 객체 자신이 가지는 데이터를 리턴하는 경우도 있는데, 이런 상황이면 객체 자신의 참조를 건네도록 할 수도 있다. (`self` 리턴?)

## 절차

1. 매개변수들을 원하는 형태로 받는 빈 함수를 만든다. <br />
→ 마지막 단계에서 이 함수의 이름을 바꿔야하니 검색하기 쉬운 이름으로 짓는다
2. 새 함수의 본문에서는 원래 함수를 호출하도록 하며, 새 매개변수와 원래 함수의 매개변수를 매핑한다
3. 정적 검사를 수행한다
4. 모든 호출자가 새 함수를 사용하게 바꾼다. 하나씩 바꾸며 테스트한다. <br />
→ 수정 후에는 원래의 매개변수를 만들어내는 코드 일부가 필요없어질 수 있다. 그러면 바로 죽은 코드 제거하기(8.9절)로 지운다
5. 호출자를 모두 수정했다면 원래 함수를 인라인(6.2절) 한다.
6. 새 함수에 좋은 이름을 붙이고 모든 호출자에 반영한다.

## 예시

### 여기서 소개하는 방안대로 리팩터하기



### 새 함수를 다른 방식으로 만들기

변형된 방안!

[^1]: 문맥상 `dataclass` 같은 개념. 데이터 담는 통 같은 느낌? C/C++의 `struct` 일 수도 있겠고 아무튼 그런 느낌 아닐까 함