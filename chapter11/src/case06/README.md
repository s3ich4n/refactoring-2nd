# 11.6 질의 함수를 매개변수로 바꾸기

_Replace Query with Parameter_

## 개요

Before

```python
target_temperature(a_plan)

def target_temperature(a_plan):
    current_temperature = thermostat.current_temperature
    ...
```

After

```python
target_temperature(a_plan, thermostat.current_temperature)

def target_temperature(a_plan, current_temperature):
    ...
```

> ![TIP]
> 반대 리팩터링: 매개변수를 질의 함수로 바꾸기 (11.5절)

## 배경

코드를 읽다보면 너무 나갔다 싶은 참조가 있다. 전역변수 참조나 영 안어울리는 원소를 참조할 때다.
그럴 때는 단순히 매개변수로 바꿔서 해결한다. 참조를 풀어내는 책임을 호출자로 바꾸는 것이다.

이런 상황은 코드의 의존관계를 바꾸려할 때 발생한다. 리팩터링하려는 함수가 더 이상 (매개변수화하려는) 특정 원소에 의존하지 않길 원할 때 발생한다.
11.5절에서 봤다시피 매개변수를 줄여야할 때, 지금처럼 허용해야할 때를 정하기 어렵다. 이런 건 ***정답이 없다***.
그렇다면 이를 위해 바꾸기 쉬운 구조를 잡는게 중요하다.

똑같은 값을 건네면 매번 똑같은 결과를 내는 함수는 다루기 쉽다. 이런 성질은 '참조 투명성' 이라 한다.
참조 투명하지 않은 원소에 접근하는 모든 함수는 참조 투명성을 잃는다. 이 문제는 그 원소를 매개변수로 바꾸면 해결된다.
책임이 호출자에 옮겨지는 건 고려해야 하지만, 모듈이 참조 투명해지는 장점은 대체로 크다.
마틴 파울러는 모듈을 개발할 때 순수 함수들은 따로 구분하고, 
프로그램의 입출력과 기타 가변원소를 다루는 로직으로 순수 함수들의 겉을 감싸는 패턴을 많이 활용한다.
이 리팩터링을 활용하면 프로그램의 일부를 순수 함수로 바꿀 수 있으며, 결과적으로 그 부분은 테스트도 용이하고 다루기도 쉬워진다.

이 리팩터링의 단점은 호출자가 어떤 값을 제공할지 알아야한다는 점이다. 호출자가 복잡해진다는 것인데, 이건 책임 소재를 프로그램의 어디에 두느냐 라는 문제로 귀결된다.
항상 정답이 없다 생각하고 프로젝트가 진행되며 균형점이 이방향저방향 옮겨질 수 있으니 세트로 알아둬야한다.

이 리팩터링의 핵심은 **의존성의 방향을 외부로 향하게 하는 것**이다.
전역 상태나 내부에서 직접 참조하던 것을 매개변수로 받아 처리함으로써, 
함수가 외부 환경과 분리되어 더 순수하고 테스트하기 쉬운 형태로 변환된다. 
예시 코드에서 볼 수 있듯이, `thermostat` 같은 외부 객체에 직접 접근하는 대신 필요한 값을 매개변수로 받아 처리함으로써 함수의 독립성과 재사용성이 높아진다.

## 절차

1. 변수 추출하기(6.3절)로 질의 코드를 함수 본문의 나머지 코드와 분리한다
2. 함수 본문 중 해당 질의를 호출하지 않는 코드들을 별도 함수로 추출(6.1절)한다
→ 이 함수의 이름은 검색하기 쉬운 이름으로 둔다 (나중에 바꿈)
3. 방금 만든 변수를 인라인(6.4절)하여 제거한다
4. 원래 함수도 인라인(6.2절)한다
5. 새 함수의 이름을 원래 함수 이름으로 고친다

## 예시

> ![NOTES]
> 
> 이 리팩터링을 하면 호출하는 쪽은 전보다 더 어려워진다.
> '의존성을 모듈 바깥으로 빼낸다'는 의존성의 책임을 호출하는 쪽이 알아야 된다란 것이다.
> 
> 다만 이걸 하면 얻는 장점은 아래와 같다:
> 
>   1. `HeatingPlan` 클래스의 불변화
>   2. `target_temperature()` 메소드의 참조투명화
>
> 예시 코드에서는 `target_temperature()`가 전역 변수인 `thermostat`에 의존하는 대신,
> 필요한 정보(`selected_temperature`)를 매개변수로 받아 처리함으로써 
> 함수가 외부 환경에 독립적으로 동작할 수 있게 되었다. 
> 이는 함수를 더 예측 가능하고 테스트하기 쉽게 만든다.
