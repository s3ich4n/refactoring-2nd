# 11장 - API 리팩터링

모듈과 함수는 소프트웨어를 구성하는 벽돌같은 것이다. API는 이 벽돌을 갖다 맞추는 연결부라 할 수 있다.
API는 이해하기 쉽게 만들어야 하고, 그렇게 하는 건 어렵다.
따라서 API 개선법을 배울 때마다 리팩터링을 계속 해야한다. 코드에 정답은 없으니까.

좋은 API는 데이터 갱신 함수와 조회함수를 명확히 분리한다[^1].
두 가지가 섞여있다면 질의함수와 변경함수 분리하기(11.1절)로 갈라야한다.
값 하나 때문에 여러 개로 나뉜 함수는 함수 매개변수화하기(11.2절)을 이용해 하나로 합칠 수 있다.
어떤 매개변수는 함수의 동작모드를 전환하는 용도로 쓰일 때가 있는데, 이는 플래그 인수 제거하기(11.3절)을 적용하면 좋다.

데이터 구조가 함수를 건너뛰며 필요이상으로 분해될 때는 객체 통째로 넘기기(11.3절)를 적용해 하나로 유지하면 깔끔해진다.
무언가를 매개변수로 건네 피호출함수가 판단할지 아닐지, 아니면 호출함수가 직접 정할지는 상황과 문맥에 따라 달라진다.
그 상황에 따라 매개변수를 질의함수로 바꾸기(11.5절), 질의 함수를 매개변수로 바꾸기(11.6절)로 바꿔가며 코드를 맞추면 된다.

클래스는 대표적인 모듈이다. 마틴 파울러는, 만든 객체가 가급적 불변임을 유지하길 윈해서 세터 제거하기(11.7절)을 권한다.
호출자(_caller_)에 새 객체를 만들어 리턴하려할 때, 일반적인 생성자로 모자란 감이 있다면 생성자를 팩토리 함수로 바꾸기 (11.8절)을 도입하는 것도 나쁘지 않은 선택이다.

수많은 데이터를 받는 복잡한 함수는 아래 방안으로 나눌 수 있다.
함수를 명령으로 바꾸기(11.9절)를 적용하면 함수가 객체화된다. 그러면 그 함수의 본문에서 함수 추출하기(6.1절)가 수월해진다.
나중에는 이 함수를 단순화하여 명령 객체가 더 필요없어지는 경우, 명령을 함수로 바꾸기 (11.10절)을 적용하여 함수로 되돌릴 수 있다.


> ![TIP]
> 
> 책에선 추가로 아래 내용도 번역되어있다.
> 
> 1. 함수 안에서 데이터가 수정되었음을 확실히 알기 위해 - 수정된 값 반환하기(11.11절)
> 
> 2. 오류코드에 의존하는 과거방식 코드를 바꾸려면 - 오류 코드를 예외로 바꾸기(11.12절).
>  단, 예외를 올바른 상황에서 정확히 적용해야한다.
> 
> 3. 문제가 되는 조건을 함수 호출 전에 검사할 수 있다면 - 예외를 사전 확인으로 바꾸기(11.13절). 예외 남용을 줄일 수 있다 

[^1]: https://martinfowler.com/bliki/CommandQuerySeparation.html
