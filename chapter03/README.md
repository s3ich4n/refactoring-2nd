# 3장 - 코드에서 나는 악취

이 장은 켄트 백과 마틴 파울러가 함께 작성했다.

둘은 "리팩터를 해야할 때가 언젠지 감을 잡아보자" 라는 주제로 글을 썼다.

리팩터 하면 해결할 수 있는 문제의 징후만을 가이드해줄 뿐, 언제 이게 좋고 나쁜지는 각자 경험을 통해 키우는 수 밖에 없다.


## 3.1. 기이한 이름

Mysterious Name

### 제안하는 내용

이름만 보고 명확하게 무슨 일을 하는 지 알아야 한다. 이름 짓는걸 어려워 하는 건 프로그래머 농담에 흔히 나오는 주제일 정도니까.

이름에는 의도가 실려야 한다.

### 사용되는 리팩터링 방안

- 함수 선언 바꾸기(6.5절)
- 변수 이름 바꾸기(6.7절)
- 필드 이름 바꾸기(9.2절)

## 3.2. 중복 코드

*Duplicated Code*

### 제안하는 내용

똑같은 코드구조가 반복되면 통합하는 것이 좋다

### 사용되는 리팩터링 방안

- 함수 추출하기(6.1절)
- 문장 슬라이드하기(8.6절)
- 메서드 올리기(12.1절)

## 3.3. 긴 함수

*Long Function*

### 제안하는 내용

함수가 짧으면 코드이해, 코드공유, 코드선택이 쉬워지는 이점도 있다.

함수는 짧을 수록 이해하기 쉽다. 현대 언어는 프로세스 내의 함수호출 비용이 없다시피 하므로 상관없다.

짧은 함수로 구성된 코드를 쉽게 이해시키려면 이름이 좋아야된다.

<aside> 💡

핵심 포인트는 함수의 목적(의도)과 구현 코드의 괴리가 크면 추출한다.

</aside>

### 사용되는 리팩터링 방안

- 함수 추출하기(6.1절) - 99%
- 함수 추출 시 매개변수와 임시변수가 많아지면…
  - 임시 변수 줄이기 - 임시 변수를 질의 함수로 바꾸기(7.4절)
  - 매개변수 줄이기 - 매개변수 객체 만들기(6.8절), 객체 통째로 넘기기(11.4절)
  - 그래도 많으면? 함수를 명령으로 바꾸기(11.9절)
- 추출할 코드 덩어리를 분석하려면 - 주석달린 부분을 함수로 빼기
- 조건문, 반복문
  - 조건문 분해하기(10.1절)
  - switch문을 구성하는 case문 마다 함수 추출하기(6.1절)을 적용해서 각 case의 본문을 함수 호출문 하나로 바꾸기
  - 같은 기준으로 나뉘는 switch문이 여러 개면 - 조건부 로직을 다형성으로 바꾸기(10.4절)
- 반복문을 메소드로 추출할 때?
  - 추출할 코드의 대표되는 이름이 안 떠오르면 - 작업이 섞여있을 수 있음 - 반복문 쪼개기(8.7절)

## 3.4. 긴 매개변수 목록

*Long Parameter List*

### 제안하는 내용

매개변수 목록이 길어지면 그 자체로 이해하기 어려워진다

### 사용되는 리팩터링 방안

- 매개변수에서 값을 얻어올 수 있는 매개변수 - 매개 변수를 질의 함수로 바꾸기(11.5절)로 제거
- 사용중인 데이터 구조에서 값을 뽑아 매개변수로 전달하는 코드는 - 객체 통째로 넘기기(11.4절)로 제거
- 항상 함께 전달되는 매개변수 - 매개변수 객체 만들기(6.8절)로 통합
- 플래그 역할의 매개변수 - 플래그 인수 제거하기(11.3절)로 제거
- 클래스를 쓰면 매개변수 목록을 줄이기 쉽다 - 여러 함수를 클래스로 묶기

## 3.5. 전역 데이터

*Global Data*

전역 데이터를 주의해야야 한다. 코드베이스 어디서든 건들일 수 있고 값을 누가 바꿨나 찾기도 어렵다. 싱글턴에서 이런 문제가 발생하기 쉽다.

### 제안하는 내용

가급적 쓰지마라. 소프트웨어 진화의 장애물이다.

변수는 접근범위를 최소화하라

### 사용되는 리팩터링 방안

- 변수 캡슐화하기 - 접근범위를 줄이고 추상화하기

## 3.6. 가변 데이터

*Mutable Data*

값을 바꿨더니 예상하지 못한 버그가 일어나는 케이스. 함수형 프로그래밍에선 복사본을 주는 형식으로 처리한다. 이를 막는 방안을 살펴보면..

### 사용되는 리팩터링 방안

- 변수 캡슐화하기(6.6절)
- 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신할 때
  - 변수 쪼개기(9.1절)
- 갱신로직의 분리
  - 문장 슬라이드하기(8.6절)
  - 함수 추출하기(6.1절)
- API 생성시?
  - 질의 함수와 변경 함수 분리하기(11.1절)
- 가능하면…
  - 세터 제거하기(11.7절)
- 사전대응 - 변수의 유효범위 최소화하거나 제한하기
  - 여러 함수를 클래스로 묶기(6.9절)
  - 여러 함수를 변환 함수로 묶기(6.10절)
  - 참조를 값으로 바꾸기(9.4절)

### 특히나…

값을 다른 곳에서 설정할 수 있는 가변데이터는 최대한 없애기

- 파생 변수를 질의 함수로 바꾸기(9.3절)

## 3.7. 뒤엉킨 변경

*Divergent Change*

이런 코드는 단일 책임 원칙을 제대로 지키지 못 할 때 나타난다. 하나의 모듈이 서로 다른 이유로 인해 여러 방식으로 바뀌는 일이 많을 때 발생한다 → 맥락별로 코드를 잘 나누어야 함을 의미

E.g.,

- 지원해야 할 DB가 추가될 때마다 함수 3개씩 바꿔야함
- 금융상품이 추가될 때마다 다른 함수 4개를 바꿔야함

<aside> 🪀

소프트웨어는 소프트해야 마땅하다

소프트웨어의 구조를 변경하기 쉬운 형태로 조작하는 것은 너무나 당연하다

코드를 바꿀 때는 시스템에서 고쳐야 할 딱 한 군데를 찾아서 그 부분만 바꿀 수 있도록 구성해야 한다

</aside>

### 사용되는 리팩터링 방안

- 순차적으로 실행되는 맥락이라면?
  - 단계 쪼개기(6.11절) - 다음 맥락에 필요한 데이터를 특정 데이터 구조에 담고 전달
- 전체 처리과정 곳곳에서 각기 다른 맥락의 함수를 호출하는 빈도가 높다면?
  - 함수 옮기기(8.1절) - 각 맥락에 해당하는 적당한 모듈들을 만들어서 함수를 모음
- 여러 맥락의 일에 관여하는…
  - …함수가 있다면 - 함수 추출하기(6.1절)
  - …클래스라면 - 클래스 추출하기(7.5절)

## 3.8. 산탄총 수술

*Shotgun Surgery*

코드를 바꿀 때마다 자잘하게 수정해야 하는 클래스가 많은 경우 - 변경할 부분이 코드 전반에 퍼져있는 경우를 의미

### 사용되는 리팩터링 방안

- 함께 바뀌는 대상을 모으기

  - 함수 옮기기(8.1절)
  - 필드 옮기기(8.2절)

- 비슷한 데이터를 다루는 함수가 많은 경우

  - 여러 함수를 클래스로 묶기(6.9절)

- 데이터 구조를 변환하거나 보강(

  enrich

  )하는 함수

  - 여러 함수를 변환 함수로 묶기

- 묶은 함수의 출력결과를 묶어서 다음 로직으로 전달할 수 있다면

  - 단계 쪼개기(6.11절)

- 어설프게 분리된 로직을 합치려면

  - 함수 인라인하기(6.2절)
  - 클래스 인라인하기(7.6절)

<aside> ⛰️

작은 함수와 클래스를 구성해야하는 것도 맞지만

코드를 재구성하는 중간과정에선 큰 덩어리로 묶을 수도 있다

</aside>

## 3.8.1. 뒤엉킨 변경과 산탄총 수술 차이점

| .               | 뒤엉킨 변경             | 산탄총수술              |
| --------------- | ----------------------- | ----------------------- |
| 원인            | 맥락을 잘 구분하지 못함 | 맥락을 잘 구분하지 못함 |
| 해법(원리)      | 맥락을 명확히 구분      | 맥락을 명확히 구분      |
| 발생과정(현상)  | 한 코드에 섞여 들어감   | 여러 코드에 흩뿌려짐    |
| 해법(실제 행동) | 맥락별로 분리           | 맥락별로 모음           |

## 3.9. 기능 편애

*Feature Envy*

모듈화의 주요 목적

- 코드를 여러 영역으로 나누고
- 영역 내의 상호작용을 최대화
- 영역 사이의 상호작용은 최소화

기능 편애?

- 어떤 함수가
  - 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 더 많이 상호작용하면?

### 사용되는 리팩터링 방안

- 데이터 근처로 옮겨주기 - 함수 옮기기(8.1절)
- 함수의 일부에서만 기능을 편애하면
  1. 독립 함수로 빼내기 - 함수 추출하기(6.1절)
  2. 원하는 모듈로 옮기기 - 함수 옮기기(8.1절)
- 함수가 쓰는 모듈이 다양하면?
  1. 가장 많은 데이터를 포함한 모듈로 옮기기…함수를 조각내고 - 함수 추출하기 (6.1절)
  2. 각각을 적합한 모듈로 옮기기

### 위 규칙과 다른 접근방법

뒤엉킨 변경 냄새를 없앨 때 활용함. 함께 변경할 대상을 한 곳에 모으는 것에 포인트를 두기

- STRATEGY PATTERN
- VISITOR PATTERN
- 자기 위임(*Self-delegation*)
- 장점?
  - 오버라이드 해야 할 동작 코드를 클래스로 격리
- 단점?
  - 간접호출이 늘어남

## 3.10. 데이터 뭉치

*Data Clumps*

함께 쓰이기 위해 몰려다니는 데이터는 뭉치게 두는 것이 좋다.

이런류의 데이터 중 값 하나를 삭제했을 때 다른 데이터로는 의미가 없다면, 데이터 뭉치로 판단할 수 있겠다.

### 사용되는 리팩터링 방안

- 필드 형태의 데이터 뭉치 처리하기
  - 하나의 객체로 묶음 - 클래스 추출하기(7.5절) 더 나아가 클래스로 옮기면 좋을 동작은 없나 살펴보기 ⇒ 중복을 줄이고 개발을 가속하는 클래스가 생기기 쉬움
- 메소드 시그니처의 데이터 뭉치 처리하기
  - 매개변수 객체 만들기(6.8절)
  - 객체 통째로 넘기기(11.4절)

## 3.11.  기본형 집착

*Primitive Obsession*

### 제안하는 내용

필요한 기초 타입은 정의해주는 편이 좋다.

### 사용되는 리팩터링 방안

- 이런 데이터를 보고… - 기본형을 객체로 바꾸기(7.3절)
- 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입코드로 쓰였다면
  - 타입 코드를 서브클래스로 바꾸기(12.6절)
  - 조건부 로직을 다형성으로 바꾸기(10.4절)
- 자주 몰려다니는 기본형 그룹? - 데이터 뭉치로 간주
  - 클래스 추출하기(7.5절)
  - 매개변수 객체 만들기(6.8절)

## 3.12. 반복되는 switch문

*Repeated Switches*

### 사용되는 리팩터링 방안

- 조건부 로직을 다형성으로 바꾸기(10.4절)

그러나, 무조건 다 바꿀 필요는 없다 - switch case가 분기 조건에 더 복잡한 타입을 지원하기도 하기 때문

문제되는 건 똑같은 조건부 로직이 여러 곳에서 반복되는 것이다.

## 3.13. 반복문

*Loops*

### 사용되는 리팩터링 방안

- 일급함수(first-class function)을 지원하면 - 반복문을 파이프라인으로 바꾸기(8.8절) 파이프라인 연산을 사용해서 원소들의 사용을 파악

## 3.14. 성의없는 요소

*Lazy Element*

한 때는 잘 쓰던 메소드, 클래스, 인터페이스는 리팩터링이 끝나면 치워내는 것이 좋다.

- 구조가 필요없거나
- 실질적 메소드가 하나뿐이거나 (알고봤더니 이 클래스에 추가를 안하게 되는 경우)

### 사용되는 리팩터링 방안

- 함수 인라인하기(6.2절)
- 클래스 인라인하기(7.6절)
- 계층 합치기(12.9절)

## 3.15. 추측성 일반화

*Speculative Generality*

### 제안하는 내용

‘나중에 필요할 것 같은데’ 라는 후킹 포인트, 특이케이스 처리로직은 나중에 추가하자. 유지보수가 어려운 코드가 되기 때문이다.

당장 안쓰는 코드면 치우고 나중에 추가하자

### 사용되는 리팩터링 방안

- 하는 일이 없는 추상클래스 - 계층 합치기(12.9절)
- 쓸데없이 위임하는 코드
  - 함수 인라인하기(6.2절)
  - 클래스 인라인하기(7.6절)
- 본문에서 쓰지 않는 매개변수 - 추가는 했는데 안 쓰는 매개변수를 이 방법으로 없애기
  - 함수 선언 바꾸기(6.5절)
- 테스트 코드에서만 쓰이는 코드
  - 죽은 코드 제거하기(8.9절)

## 3.16 임시 필드

*Temporary Field*

### 제안하는 내용

특정 상황에서만 값이 설정되는 필드를 지우기. 객체엔 모든 필드가 있길 바라고 써야하기 때문

### 사용되는 리팩터링 방안

- 클래스 추출하기(7.5절) → 의미있게 모으기
- 함수 옮기기(8.1절) → 임시필드와 연관된 코드를 새 클래스로 이사보내기
- 임시 필드가 유효한지 확인후 동작하는 코드
  - 특이 케이스 추가하기(10.5절)

## 3.17 메시지 체인

*Message Chain*

클라이언트가 한 객체를 통해 다른 객체를 얻고, 방금 얻은 객체에 또 다른 객체를 줄줄 요청하는 형태

클라이언트가 객체 내비게이션 구조에 종속되었다는 신호

### 사용되는 리팩터링 방안

- 위임 숨기기(7.7절)

- 중간 객체들이 모두 중개자(

  middle man

  , 3.18절)가 될 수 있음. 이를 대비하기 위해

  - 결과 객체를 쓰는 코드를 빼내고 - 함수 추출하기(6.1절)
  - 체인을 숨김 - 함수 옮기기(8.1절)

?? 다시 보자 나중에

## 3.18 중개자

*Middle Man*

객체는 세부사항을 숨기는 캡슐화(*encapsulation*)를 자주 사용한다. 그 과정에서 위임(*delegation*)을 자주 활용한다. 문제는 객체의 위임이 지나친 경우다.

### 사용되는 리팩터링 방안

- 실제 일하는 객체와 직접 소통하게 하기 - 중개자 제거하기(7.8절)
- 위임메서드를 빼고 남는 일이 거의 없다면 - 함수 인라인하기(6.2절)

## 3.19 내부자 거래

*Insider Trading*

모듈 간 결합도가 높다면 최소로 줄이고 투명하게 바꿔야 한다.

### 사용되는 리팩터링 방안

- 함수 옮기기(8.1절)
- 필드 옮기기(8.2절)
- 여러 모듈이 같은 관심사를 공유한다면?
  - 공통부분을 처리하는 제 3의 모듈 만들기, 위임 숨기기(7.7절)
- 부모-자식 클래스 간 의존도가 너무 높다면?
  - 서브클래스를 위임으로 바꾸기(12.10절)
  - 슈퍼클래스를 위임으로 바꾸기(12.11절)

## 3.20 거대한 클래스

*Large Class*

클래스가 너무 많은 책임을 지고있으면 필드도, 중복코드도 늘어날 수 있다. 이를 추출해내고 제거해야한다.

### 사용되는 리팩터링 방안

- 클래스 추출하기(7.5절)
- 분리할 컴포넌트를…
  - 원래 클래스나 상속관계로 만드는게 좋다면
    - 슈퍼클래스 추출하기(12.8절)
    - 타입 코드를 서브클래스로 바꾸기(12.6절) - 실질적 서브클래스 추출하기 역할
- 중복을 최대한 빼기
- 클라이언트의 거대 클래스 사용패턴을 파악한 후…
  - 클래스 추출하기(7.5절)
  - 슈퍼클래스 추출하기(12.8절)
  - 타입 코드를 서브클래스로 바꾸기(12.6절)

## 3.21 서로 다른 인터페이스의 대안 클래스들

*Alternative Classes with Different Interfaces*

클래스는 다른 클래스로 교체하기 쉽다. 그러려면 인터페이스가 같아야한다.

### 사용되는 리팩터링 방안

- 메소드 시그니처 일치시키기 - 함수 선언 바꾸기(6.5절)
- 인터페이스가 같아질 때 까지 필요 동작을 클래스에 밀어넣기 - 함수 옮기기(8.1절)
- 대안 클래스 사이에 중복코드가 생기면 - 슈퍼클래스 추출하기(12.8절)

## 3.22 데이터 클래스

*Data Class*

데이터 저장용 클래스 처리 방안

### 사용되는 리팩터링 방안

- public 필드에 대해… - 레코드 캡슐화하기(7.1절)
- 변경불가 필드는… - 세터 제거하기(11.7절)
- 다른 클래스에서 데이터클래스의 getter,setter를 쓰는 메소드를 찾고 - 함수 옮기기(8.1절) → 그걸 데이터클래스로 옮기기
- 함수 추출하기(6.1절)도 유효함

immutable 데이터는 굳이 캡슐화할 필요가 없음

## 3.23 상속 포기

*Refused Bequest*

### 사용되는 리팩터링 방안

- 서브클래스가 부모의 동작은 필요로 하지만 인터페이스를 따르고 싶어하지 않을 때
  - 서브클래스를 위임으로 바꾸기(12.10절)
  - 슈퍼클래스를 위임으로 바꾸기(12.11절)

## 3.24 주석

*Comments*

주석이 나쁠 이유는 없다.

다만 남발하지 말고, 항상 최신의 내용을 담는 주석이 되도록 유지해야한다.

### 사용되는 리팩터링 방안

- 특정 코드블록이 하는 일에 주석을 남기고 싶다면 - 함수 추출하기(6.1절)
- 추출된 함수임에도 설명이 필요하다면 - 함수 선언 바꾸기(6.5절)
- 시스템이 동작하기 위한 선행조건을 명시하고 싶다면 - 어서션 추가하기(10.6절)
