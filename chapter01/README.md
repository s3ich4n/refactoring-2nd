# 1장

예시를 토대로 살펴봅시다.

## 1.1. 시작해봅시다

코드 따라치는데 대체로 비슷하게 했다.

요구사항

- 공연요청, 관객규모를 기초로 비용을 책정하는 프로그램 작성
- 비극, 희극만 궁연함
- 공연료와 포인트(`volume_credit`)을 지급해서, 다음 번 의뢰시 공연료 할인도 가능함

## 1.2. 예시 프로그램을 본 소감

쉽지않다 ㅋㅋ

그래도 어쨌든 작동한다. 그런데 설계가 나쁘면 고치기가 어렵다. 손대기가 어려우면 버그가 날 가능성이 높아진다.

코드 수정이 필요하면? 작동방식을 쉽게 파악할 수 있도록 코드를 여러 함수와 프로그램 요소로 재구성한다.
구조부터 다시 잡고 기능을 수정하는 편이 좋다.

> 프로그램이 새 기능을 추가하기 편한 구조가 아니면, 기능을 잡기 쉬운 구조로 바꾸자.

### 추가 요구사항 (1)

"청구내역을 HTML로 출력해야한다" 면...

현재 `statement()` 을 그대로 쓰면 함수가 너무 복잡해진다.

대안 1: 함수 복붙 후 거기서 HTML을 출력(`html_statement()`)

한번 짜고 말 코드면 그래도 되지만, 오래 쓸 프로그램이면 골치아파진다.

### 추가 요구사항 (2)

배우가 연기하고 싶은 장르가 많아진다면, 공연료 및 적립 포인트 계산방식도 바뀐다. "거의 확실히 바뀐다".

대안 2: 또 함수 복붙 후 로직 수정

그럼 대안 1에서 만든 `html_statement()` 에도 반영해야한다.

정책이 복잡해지면 수정할 부분 찾기도 힘들고 실수도 필연적이다.

### 그래서...

리팩터링은 변경을 위해 필요하다.

## 1.3. 리팩터링의 첫 단계

1. 테스트코드를 마련한다.
    - 청구서 몇개를 준비하고
    - `statement()` 의 정답 문자열과 비교한다.
    - 단축키 딸깍으로 테스트를 바로 볼 수 있게 세팅한다.

> 리팩터링 하기 전에 테스트부터 마련한다. 테스트는 자가진단하도록 만든다

## 1.4. `statement()` 함수 쪼개기

전체 동작을 각각의 부분으로 나누는 지점부터 물색 -- switch case[^1]

이런 switch문은 코드 스스로가 할 수 있도록 함수로 추출해야한다[^2]. 이름은 `amount_for(a_performance)` 정도로.

PyCharm에는 Refactor 단축키 입력 후 Extract Method를 하면 된다.

원래는 별도 메소드로 빼주는데, 책에서 nested function으로 처리해서 이를 동일하게 반영했다.

변수명을 일괄적으로 바꾸는 것도 IDE가 해준다.
매개변수의 역할이 명확하지 않으면 `a/the` 를 붙이는 건 영어가 모자라서 이해를 못했지만,
아무튼 그런 접근을 해야된단 건 배웠다.

### `play` 변수 제거하기

`amount_for()` 의 매개변수를 살펴보면, `a_performance`는 어차피 루프변수에서 온다.
`play` 는 개별 공연(`a_performance`)에서 온다.
그러면 `amount_for()` 안에서 계산하는 편이 낫다.

임시변수를 최소화해서 추출을 단순화한다.
이는 임시 변수를 질의 함수로 바꾸기[^3]라고 한다.

변수를 인라인 처리[^4]했다.
이후 변수 인라인으로 인해 함수 선언을 바꿀[^5] 수 있었다.
불필요한 파라미터를 지운 건 덤이다.

근데 이렇게 리팩터링 하면 루프 한번 돌 때마다 공연을 조회했는데, 이러면 세 번 조회한다.
제대로 리팩터되면 성능개선도 금방 할 수 있다.

다시 호출부로 돌아간다. `amount_for()` 는 임시 변수인 this_amount에 값을 설정하는데 쓰지만 그 값이 바뀌진 않는다.
변수 인라인하기를 재적용한다.

### 적립 포인트 계산 코드 추출하기

점점 나아지고있다... 이제 적립 포인트 계산 로직을 추출하자.
`perf` 변수도 간단히 전달만 하자. 그런데 `volume_credits` 는 반복하면서 값을 누적해야한다
=> 추출한 함수에서 `volume_credits`의 복제본을 초기화하고 계산결과를 반환하면 된다.

### `format` 변수 제거하기

임시변수는 문제를 일으키기 쉬우므로 이를 지운다.
그 대상은 `format` 이다. 가장 쉬운 방법은 함수 변수를 일반 함수로 바꾸는 정도다.
이름 짓기도 매우 중요하기 때문에 함수 선언 바꾸기를 또 썼다.
하는 김에 비즈니스 로직도 메소드에 추가했다.

### `volume_credits` 변수 없애기

반복문을 돌 때마다 값이 누적되는 걸 살펴보기 까다로우므로 반복문 쪼개기[^6]를 이용해 별도로 빼낸다.
이 후 문장 슬라이드하기[^7]로 `volume_credits` 변수를 선언하는 문장을 반복문 바로 뒤로 옮겼다.

`volume_credits` 값 갱신과 관련한 코드를 한데 모아두면 임시 변수를 질의 함수로 바꾸기가 쉬워진다.
이를 위해 함수로 추출부터 다시 한번 해본다. 잘 끝났으면 변수를 인라인한다.

앞서 말한 리팩터링으로 인한 성능저하가 염려될 수 있다.
설령 그렇다 하더라도 다듬어진 코드로 성능 개선을 하는게 훨씬 쉽다.

성능은 "특별한 경우가 아니라면 일단 무시"한다.

`volume_credits`는 4단계로 잘게 나눴다:

1. 반복문을 쪼갰고 (`62955c57`)
2. 문장 슬라이드를 했고 (`9bbb6536`)
3. 함수를 추출했고 (`2bc5c439`)
4. 변수를 인라인했다 (`2c57d61d`)

똑같은 작업을 `total_amount` 에서도 해보자.

1. 함수를 추출했고 (`73572616`)
2. 변수를 인라인했다 (`3d1fe1eb`)

## 1.5. 중첩함수로 난리도 아니네요

어쨌든 리팩터 하긴 했습니다.

## 1.6. 계산단계와 포매팅 단계 분리하기

먼저 논리흐름부터 다듬었다. 그 다음엔 요구사항을 반영해보자. `statement()`의 HTML 버전만들기를 하자.

그렇다면 HTML버전으로 하기 위해 중첩함수부터 다 나누자.

함수 추출하기부터 다시 시작하자.

이후 중간데이터 구조를 할 객체를 만들자. 그 과정이 단계 쪼개기[^8]이다.
전달되는 데이터를 여기로 옮기면, 계산 관련 코드는 `statement()`에, `render_plain_text()` 에는 데이터 매개변수로 전달된 데이터만 처리가능.

이후 `invoice, plays`를 `data` 안으로 옮겨버린다.
그리고 중간 데이터 구조에서 관련 처리를 수행한다.

함수를 적절히 옮긴다[^9].

play_for, amount_for를 옮겼다.
적립 포인트, 총액을 바꾸고, 반복문을 파이프라인 형태로[^10] 바꿨다.

## 1.7. 중간점검 - 두 파일과 두 단계로 나뉘어짐

전체 로직의 구성요소를 명확히 나눴다
계산부분, 출력부분을 명확하게 나눴다

=> 코드 중복없이 HTML 버전이 만들어졌다

> 코드베이스를 작업 시작 전보다 건강하게 만들어 놓아야 한다.

## 1.8. 다형성을 활용해 계산 코드 재구성하기

조건부 로직은 객체지향의 핵심 특성인 다형성으로 푸는 것[^11]이 자연스럽다.

따라서 상속계층을 정의하고 상태와 행위를 정의하는 객체를 생각해보자.

함수들을 살펴보니 대충 뭔 행동이 있는진 알겠고. 우선 "공연료를 계산한다" 라는 행동을 정의해보자.

### 공연료 계산기 만들기

함수 선언 바꾸기[^12]로 공연할 연극을 계산기로 전달한다.

이후 함수 옮기로 클래스 메소드[^13]로 바꾼다.

### 공연료 계산기를 다형성 버전으로 바꾸기

다형성을 지원하려면 서브클래스를 쓰게 변경[^14]하면 된다.

딱맞는 서브클래스를 쓰려면 생성자 대신 함수를 호출하게 변경해야 한다.
이를 위해 생성자를 팩터리 함수로 바꾸기[^15] 를 사용한다.

> 파이썬에서는 서브 클래스의 인스턴스를 `@classmethod` 로 리턴하는 편이 더 깔끔해서 이렇게 처리했다
> 
> 서브클래스의 인스턴스를 부모에서 결정해줄 수 있기 때문이다.

이후 조건부 로직을 다형성으로 바꾼다[^16].

## 1.9 상태 점검: 다형성을 활용하여 데이터 생성하기

- 연극 장르별 계산코드를 별도 처리
- 조건부 생성로직을 생성함수로 옮김

## 1.10 마치며

아래 세 단계로 리팩터를 진행함

1. 중첩함수로 나누기
2. 단계 쪼개기를 적용해서 계산코드와 출력 코드를 분리함
3. 계산 로직을 다형성으로 표현함

리팩터링은 코드가 하는 일을 파악하고, 개선점을 찾은 후 그걸 반영하는 식으로 한다.
계속해서 이해하기 쉽도록 선순환을 반복한다. 이러면 원본 코드보다는 유지보수하기 나아졌다고 본다.

코드 개선에 대해 내린 지침은 아래와 같다:

- 고치기 쉬운 코드를 위해 최소한의 리팩터 후 테스트코드를 구성한다
- 고치기 쉬운 코드를 짜고, 계속 이렇게 짜도록 가늠하고 생각한다
- 건강한 코드 베이스를 통해 생산성을 극대화하고 요구사항을 더 빠르고 저렴한 비용으로 제공할 수 있게 한다
- 리팩터 시 아래 리듬을 계속 가져가는 것이 좋다
   - 각 단계를 굉장히 잘게 나눔
   - 매번 테스트함(컴파일 언어라면 컴파일까지)
   - 이러면 더 빠르게 바뀌고, 깨질 일이 없고, 변화가 쌓여서 거대한 변화가 된다는 점이다
   
앞으로도 이렇게 해봐야겠다.

[^1]: 파이썬에서는 pattern match 구문
[^2]: `6.1`절, 함수 추출하기
[^3]: `7.4`절, 임시 변수를 질의 함수로 바꾸기
[^4]: `6.4`절, 변수 인라인하기
[^5]: `6.5`절, 함수 선언 바꾸기
[^6]: `8.7`절, 반복문 쪼개기
[^7]: `8.6`절, 문장 슬라이드하기
[^8]: `6.11`절, 단계 쪼개기
[^9]: `8.1`절, 함수 옮기기
[^10]: `8.8`절, 반복문을 파이프라인으로 바꾸기
[^11]: `10.4`절, 조건부 로직을 다형성으로 바꾸기
[^12]: `6.5`절, 함수 선언 바꾸기
[^13]: (in Python) `@classmethod` 가 아니라 클래스에 속한 메소드로 리팩터한다는 의미.
[^14]: `12.6`절, 타입 코드를 서브클래스로 바꾸기
[^15]: `11.8`절, 생성자를 팩터리 함수로 바꾸기
[^16]: `10.4`절, 조건부 로직을 다형성으로 바꾸기