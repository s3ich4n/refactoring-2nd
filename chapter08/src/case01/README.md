# 8.1 함수 옮기기

_Move Function_

## 개요

Before

```python
class Account:
    def overdraft_charge(self): ...
```

After

```python
class AccountType:
    def overdraft_charge(self): ...
```

## 배경

좋은 소프트웨어 설계의 핵심은 모듈화가 얼마나 잘 되어있는지를 뜻하는 모듈성(_modularity_)에 있다.
모듈성은 프로그램의 어딘가를 수정하려 할 때 해당 기능과 깊이 관련된 작은 일부만 이해해도 가능하게 해주는 능력이다.
모듈성을 높이려면 연관된 요소들을 묶고, 그 요소 간의 연결관계를 쉽게 찾고 이해할 수 있도록 해야한다.
하지만 프로그램을 얼마나 잘 이해했느냐에 따라 구체적인 방법은 달라질 수 있다.
보통은 이해도가 올라갈 수록 코드들을 잘 묶는 새로운 방법이 도출된다.
높아진 이해를 코드에 반영하기 위해선 요소들을 잘 옮길 수 있어야 한다.

모든 함수는 컨텍스트 내에 존재한다. 전역함수도 있지만 대부분은 특정 모듈에 속한다.
객체지향 프로그래밍의 핵심 모듈화 컨텍스트는 클래스다. 또한 함수를 다른 함수에 중첩시켜도 또 다른 공통 컨텍스트를 만들게 된다.
프로그래밍 언어는 각각의 모듈화 수단을 제공하며, 그 수단이 함수가 제 역할을 하는 컨텍스트를 만들어 준다.

근데 어떤 함수 가 자신이 속한 모듈 A보다 모듈 B의 요소를 더 많이 참조하면 옮겨주는게 좋다.
이러면 캡슐화가 좋아져서 이 소프트웨어의 나머지 부분은 모듈 B의 세부사항에 덜 의존하게 된다.

이와 비슷하게, 호출자들의 현재 위치(호출자가 속한 모듈)나 다음 업데이트 때 바뀌리라 예상되는 위치에 따라서도 함수를 옮겨야할 수도 있다.
예를 들어 다른 함수 안에서 도우미 역할로 정의된 함수 중 독립적으로도 고유한 가치가 있는 건 접근하기 더 쉬운데로 옮기는게 낫다.
혹은 다른 클래스로 옮겨두면 쓰기 더 편한 메소드도 있다.

함수를 옮길지 말지를 정하는 건 쉽지 않다. 그럴 땐 대상 함수의 현재 컨텍스트와 후보 컨텍스트를 둘러보면 도움이 된다.
이 함수를 호출하는 함수는 무엇인지, 이 함수가 호출하는 함수는 무엇인지, 이 함수가 쓰는 데이터는 뭔지도 살펴봐야한다.
서로 연관있는 여러 함수를 묶을 새 컨텍스트가 필요하다면 여러 함수를 클래스로 묶기(6.9절), 클래스 추출하기(7.5절)로 접근할 수도 있다.
어려울 수 있으나, 선택이 어려울 수록 큰 문제가 아닌 경우가 많다.
마틴 파울러의 경험 상 한 컨텍스트에 두고 작업해버린 후에, 어디로 따로 빼면 좋을지 차차 드러나는 경우도 있다고 한다.
그러면 앞으로 배울 리팩터링 기법들을 배워서 옮겨버리면 그만이니까.

## 절차

1. 선택한 함수가 현재 컨텍스트에서 사용중인 모든 프로그램 요소를 살펴본다. 이 요소 중 함께 옮겨야 할 게 있나 살펴본다. <br />
→ 호출되는 함수 중 함께 옮길 게 있으면 그 함수부터 옮기는게 낫다. 얽힌 함수가 여러개면 영향이 적은 것 부터 옮기는 것이 좋다. <br />
→ 하위 함수들의 호출자가 고수준 함수 하나뿐이면 하위 함수를 고수준 함수에 인라인하고, 고수준 함수를 옮기고, 옮긴 위치에서 개별함수로 다시 풀어내자
2. 선택한 함수가 다형 메소드인지 확인한다 <br />
→ 객체지향 언어는 같은 메소드가 슈퍼클래스나 서브클래스에 선언되어있는지도 고민해야한다.
3. 선택한 함수를 타깃 컨텍스트로 복사한다[^1]. 타깃 함수가 잘 자리잡게 구성한다. <br />
→ 함수 본문에서 소스 컨텍스트의 요소를 사용한다면 해당 요소들을 매개변수로 넘기거나 소스 컨텍스트 자체를 참조로 넘겨준다 <br />
→ 함수를 옮기게 되면 새 컨텍스트에 어울리는 새 이름으로 바꿔줘야 할 경우가 많다. 필요하면 바꾼다
4. 정적 분석을 수행한다
5. 소스 컨텍스트에서 타깃 함수를 참조할 방법을 찾아 반영한다
6. 소스 함수를 타깃 함수의 위임 함수가 되도록 수정한다
7. 테스트한다
8. 소스 함수를 인라인(6.2절)할지 고민한다 <br />
→ 소스 함수는 언제까지라도 위임 함수로 남겨둘 수 있다. 하지만 소스 함수를 호출하는 곳에서 타깃 함수를 직접 호출하는 데 무리가 없다면 중간 단계(소스 함수)는 제거하는 게 낫다


## 예시

### 예시 (1)

중첩함수는 숨겨진 데이터끼리 상호작용하기 쉬우므로 되도록 만들지 말자

### 예시 (2)

계좌 종류에 따라 이자 책정 알고리즘을 다르게 표현하기로 결정했다면, `overdraft_charge` 를 옮기는 편이 좋을 것이다.
이를 테스트해보자.

`@property` 를 쓰면, 바로 연산되니까 달리 상관없을 것이라고 판단. read-only computed value니까 더 자연스럽기도 하다

메소드를 쓸 때는 아래 케이스가 더 낫다고 본다:

- 파라미터가 생길 때(property는 파라미터를 못 받으니까)
- 무거운 작업임을 알리고싶을 때 
- 상태 변동에 따라 재계산이 필수적일 때


[^1]: 원래 함수를 소스 함수(_source function_)으로 일컫고, 복사해서 만든 함수를 타깃 함수(_target function_) 라고 한다