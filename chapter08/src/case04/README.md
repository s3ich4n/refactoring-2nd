# 8.4 문장을 호출한 곳으로 옮기기

_Move statements to caller_

## 개요

Before

```python
def emit_photo_data(out_stream, photo):
    out_stream.write(f"<p>title: {photo.title}</p>\n")
    out_stream.write(f"<p>location: {photo.location}</p>\n")

emit_photo_data(out_stream, person.photo)
```

After

```python
def emit_photo_data(out_stream, photo):
    out_stream.write(f"<p>title: {photo.title}</p>\n")

emit_photo_data(out_stream, person.photo)
out_stream.write(f"<p>location: {person.photo.location}</p>\n")
```

## 배경

함수는 프로그램의 추상화 관점에서 보는 기본 빌딩 블록이다.
이 추상화의 경계를 잘 긋는 것은 쉽지않다. 코드베이스의 기능범위에 따라 계속 달라지기 때문이다.
함수는 응집도도 높고 하나의 일만 하다가, 여러 일을 하게 될 수도 있다는 뜻이다.

예를들어 여러 곳에서 쓰이던 기능이 일부 호출자에게는 다르게 동작하게끔 바뀌어야 한다면 여러 일을 하는 상황이 발생할 수 있다.
그렇다면 이 달라진 동작은 함수에서 꺼내서 해당 호출자로 옮겨야 한다.
이런 상황에선 문장 슬라이드 하기(8.6절)을 통해 달라지는 동작을 함수의 시작 혹은 끝으로 옮긴 후 바로 이어서 문장을 호출한 곳으로 옮기기(지금 배우는 기법) 리팩터링을 적용한다.
달라진 동작을 호출자로 옮긴 뒤엔 필요할 때마다 독립적으로 쓸 수 있다.

작은 변경이면 문장만 옮겨도 무방하지만, 호출자/호출대상의 경계를 다시 잡아야 할 정도로 큰 변화가 예상된다면
함수 인라인하기(6.2절)부터 적용하고 문장 슬라이드하기(8.6절), 함수 추출하기(6.1절)로 더 적합한 경계를 다시 그어보자.

## 절차

1. 호출자가 한두개뿐이고 피호출 함수도 간단하면 피호출함수의 처음 혹은 마지막 코드를 잘라서 호출자에 복사한다. (필요하면 적절하게 수정). 테스트만 통과하면 끝이다.
2. 더 복잡하면, ***이동하지 않았으면*** 하는 모든 문장을 함수로 추출(6.1절)한다. 검색하기 쉬운 이름을 붙여준다. <br /> 
→ 대상 함수가 서브클래스에서 오브라이드 되었다면 오버라이드한 서브클래스들의 메소드 모두에서 동일하게, 남길 부분을 메소드로 추출한다. 남겨질 메소드의 본문은 모든 클래스에서 똑같아야 한다. 그런 다음 (슈퍼클래스의 메소드만 남기고) 서브클래스들의 메소드를 제거한다.
3. 원래 함수를 인라인(6.2절)한다
4. 추출된 함수의 이름을 원래 함수 이름으로 변경한다(6.5절) <br />
→ 더 나은 이름이 떠오르면 그걸로 바꾼다

## 예시

`list_recent_photos`가 `location` 정보를 다르게 렌더해야한다고 가정하고, `emit_photo_data` 를 리팩터링 해보자.

`render_person` 의 마지막 두 줄을 잘라서 호출코드 밑에 넣으면 그만인데, 정석대로 가보자.

1. `location`은 인라인 시키고 다른 함수 (`zztmp`) 에 동작을 뺀 후 이름을 바꿔준다 (dfe345ee24340dcf601934d0b3491c1fd4e3a3c7)
2. 피호출 함수를 호출자들로 한 번에 하나씩 인라인한다. 하면서 테스트한다. (255a0124954729f88d18b80a3731ccff01c1a48d)
3. 이름을 원래대로 돌리면... (e4feab23858155f854f55c2c51e1f109ed0a05a1)

끝.
