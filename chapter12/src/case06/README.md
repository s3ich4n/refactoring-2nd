# 12.6 타입 코드를 서브클래스로 바꾸기

_Replace Type Code with Subclasses_

## 개요

Before

```python
def create_employee(name, user_type):
    return Employee(name, user_type)
```

After

```python
def create_employee(name, user_type):
    if user_type == UserType.ENGINEER:
        return Engineer(name)
    elif user_type == UserType.SALESPERSON:
        return Salesperson(name)
    elif user_type == UserType.MANAGER:
        return Manager(name)
    else:
        raise NotImplementedError(f"{user_type} is not found")

```

## 배경

소프트웨어 시스템은 비슷한 대상을 특성에 따라 구별할 때가 많다. 이때는 타입 코드(_type code_)로 이를 가른다.
이런 건 열거형, 심볼, 문자열, 숫자 등으로 표현하며 특히 외부 서비스가 제공하는 데이터를 다룰 때 딸려오는 일이 흔하다.

타입 코드만으로도 괜찮지만, 그 이상의 것이 필요할 때가 있다. 서브클래스로 다룰 때가 바로 그 때다.
서브클래스는 두 가지 면에서 매력적이다:
1. 조건에 따라 다르게 동작해주는 다형성을 갖춤 -- 타입코드에 따라 동작이 달라져야 하는 함수가 여러 개일 때 유용하다. <br />
   서브클래스를 이용하면 이런 함수에 조건부 로직을 다형성으로 바꾸기 (10.4절)를 적용할 수 있다.
2. 특정 타입에서만 의미가 있는 값을 사용하는 필드나 메소드가 있을 때 <br />
   '판매 목표'는 '영업자'유형에서 의미가 있다. 이런 상황은 서브클래스를 만들고 필요한 서브클래스만 필드를 갖도록(12.5절) 한다

이 리팩터링은 대상 클래스에 직접 적용할 것인지, 타입코드 자체에 적용할 것인지를 고민해야한다.
- 대상 클래스에 직접 적용 → 하위 타입 생성
- 타입코드 자체에 적용 → 직원에게 직원유형 '속성'을 부여하고, 이 속성을 클래스로 정의해 '엔지니어' 속성과 '관리자' 속성 

대상클래스를 직접 서브클래싱하는 건 간단하지만 다른 용도로 쓰기는 어렵다. 유형이 불변일 때도 이용할 수 없다.
서브클래싱 대상을 속성 형태로 적용하려면, 타입 코드에 기본형을 객체로 바꾸기(7.3절)를 적용하여 직원 유형 클래스를 만들고 이 클래스에 이번 리팩터링을 적용한다

## 절차

1. 타입 코드 필드를 자가 캡슐화한다
2. 타입 코드 값 하나를 선택하여 그 값에 해당하는 서브클래스를 만든다. 타입 코드 게터 메소드를 오버라이드하여 해당 타입 코드의 리터럴 값을 반환하게 한다
3. 매개변수로 받은 타입 코드와 방금 만든 서브클래스를 매핑하는 선택로직을 만든다 <br />
→ 직접 상속의 경우: 생성자를 팩토리 함수로 바꾸기(11.8절)로 적용하고 선택 로직을 팩토리에 추가 <br />
→ 간접 상속의 경우: 선택자 로직을 생성자에 추가
4. 테스트한다
5. 타입 코드 값 각각에 대해 서브클래스 생성과 선택 로직 추가를 반복한다. 클래스 하나가 완성될 때마다 테스트한다
6. 타입 코드 필드를 제거한다
7. 테스트한다
8. 타입 코드 접근자를 이용하는 메소드 모두에 메소드 내리기(12.4절), 조건부 로직을 다형성으로 바꾸기(10.4절)를 적용한다

## 예시

### 예시 (1) - 직접상속

- 생성 메소드로 다형성 처리를 하고,
- 필드는 다형성으로 바꾸로 메소드를 내려서 해결했다.
- 불필요한 타입점검도 if-else로 처리했으니 안쓰는 코드는 삭제.
- `__str__`을 어떻게 할지 고민하다가 클래스 이름으로 결정. 이 코드는 좀 안좋은 것 같기도..?

### 예시 (2) - 간접상속

이 케이스에선 `Employee`의 서브 클래스로 알바와 정직원이 있어서, 직접상속하기 곤란한 경우가 있다고 가정하자.

