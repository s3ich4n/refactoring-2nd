# 12.10 서브클래스를 위임으로 바꾸기

_Replace Subclass with Delegate_

## 개요

Before

```python
class Order:
    def __init__(self, warehouse):
        self._warehouse = warehouse
    
    @property
    def days_to_ship(self):
        return self._warehouse.days_to_ship


class PriorityOrder(Order):
    def __init__(self, warehouse, priority_plan):
        super().__init__(warehouse)
        self._priority_plan = priority_plan
    
    @property
    def days_to_ship(self):
        return self._priority_plan.days_to_ship
```

After

```python
class Order:
    def __init__(self, warehouse, priority_delegate=None):
        self._warehouse = warehouse
        self._priority_delegate = priority_delegate
    
    @property
    def days_to_ship(self):
        if self._priority_delegate:
            return self._priority_delegate.days_to_ship
        return self._warehouse.days_to_ship


class PriorityOrderDelegate:
    def __init__(self, priority_plan):
        self._priority_plan = priority_plan
    
    @property
    def days_to_ship(self):
        return self._priority_plan.days_to_ship
```

## 배경

속한 갈래에 따라 동작이 달라지는 객체는 상속으로 표현하는게 자연스럽다. 공통 데이터와 동작은 슈퍼클래스에, 서브클래스는 오버라이딩을 한다.

상속은 단점이 있다. 가장 명확한 단점은 한 번만 쓸 수 있는 카드라는 것이다.
무언가가 달라져야 하는 이유가 여러 개여도 상속에서는 그중 단 하나의 이유만 선택해 기준으로 삼을 수 밖에 없다.
예를들어 "사람"이란 객체의 동작을 '나이대', '소득 수준'에 따라 달리 하고싶다면 서브클래스는 '젊은이', '어르신'이 되거나, '부자', '서민'이 되어야 한다. 둘 다는 안 된다.

다음 단점은 클래스 간의 관계를 매우 긴밀하게 결합한다.
부모의 변경은 자식 모두에 영향이 간다. 따라서 자식들이 어떻게 상속해서 쓰는지 이해해야 한다.
부모와 자식이 서로 다른 모듈에 속하거나 다른 팀에서 구현한다면 문제는 더 커진다.

위임(_delegate_)은 이 모든 문제를 해결해준다. 다양한 클래스에 서로 다른 이유로 위임할 수 있다.
위임은 객체 간의 일반적 관계이므로 상호작용에 필요한 인터페이스를 명확히 정의할 수 있다. 즉, 상속보다 결합도가 매우 약하다.
이런 이유로 서브클래싱(상속) 문제에 직면하면 서브클래스를 위임으로 바꾼다.

GoF 책에도 보면 "구현 상속(_inheritance_) 보다는 (인터페이스 상속을 기반으로한) 객체 조합(_composition_)을 선호하라"[^1] 라는 말이 나온다.
composition은 사실상 위임과 같은 말이다. 상속은 안 좋은 것이 아니다. 필요하면 상속으로 관계를 풀면 되고, 나중에라도 필요하면 바꾸면 된다.
마틴 파울러도 상속으로 접근 후, 문제가 발생하면 그때 위임으로 바꾼다.
과용에 대한 반작용을 경고하는 것이지, "쓰지 마라"라고 오해하면 안 된다.

GoF의 디자인패턴을 본 적이 있다면 이 리팩터링을 서브클래스를 STATE 나 STRATEGY 로 대체 한다 정도로 이해하면 된다.
구조적으로도 호스트 위임 방식을 이용해 계층 구조를 분리해준다.
서브클래스를 위임으로 바꾸는 모든 경우에서 위임을 계층 구조로 설계해야하는 건 아니다.
하지만 STATE, STRATEGY에 계층 구조를 적용하면 유용할 때가 많다.

## 절차

`<br />`, `→` 복사해서 쓰기

1. 생성자를 호출하는 곳이 많다면 생성자를 팩토리 함수로 바꾼다(11.8절)
2. 위임으로 활용할 빈 클래스를 만든다. 이 클래스의 생성자는 서브클래스에 특화된 데이터를 전부 받아야 하며, 보통은 슈퍼클래스를 가리키는 역참조(_back reference_)도 필요하다
3. 위임을 저장할 필드를 슈퍼 클래스에 추가한다.
4. 서브클래스 생성 코드를 수정하여 위임 인스턴스를 생성하고 위임 필드에 대입해 초기화한다 <br />
→ 이 작업은 팩토리 함수가 수행한다. 아니면 생성자가 정확한 위임 인스턴스를 생성할 수 있는 게 확실하다면 생성자에서 수행할 수도 있다
5. 서브클래스의 메소드 중 위임 클래스로 이동할 것을 고른다
6. 함수 옮기기(8.1절)를 적용해 위임 클래스로 옮긴다. 원래 메소드에서 위임하는 코드는 지우지 않는다 <br />
→ 이 메소드가 사용하는 원소 중 위임으로 옮겨야 하는 게 있다면 함께 옮긴다. 슈퍼클래스에 유지해야 할 원소를 참조한다면 슈퍼클래스를 참조하는 필드를 위임에 추가한다
7. 서브클래스 외부에도 원래 메소드를 호출하는 코드가 있다면 서브클래스의 위임 코드를 슈퍼클래스로 옮긴다. 이 때 위임이 존재하는지를 검사하는 보호코드로 감싸야 한다. 호출하는 외부 코드가 없다면 원래 메소드는 죽은 코드가 되므로 제거한다(8.9절)
→ 둘 이상의 서브클래스들에서 중복이 생겨나기 시작했다면 슈퍼클래스로 추출(12.8절)한다. 이렇게 해서 기본 동작이 위임 슈퍼클래스로 옮겨졌다면 슈퍼클래스의 위임 메소드들에는 보호 코드가 필요없다
8. 테스트한다
9. 서브클래스의 모든 메소드가 옮겨질 때 까지 5~8을 반복한다
10. 서브클래스들의 생성자를 호출하는 코드를 찾아서 슈퍼클래스의 생성자들을 사용하도록 수정한다
11. 테스트한다
12. 서브클래스를 삭제한다(죽은 코드 제거하기, 8.9절)

## 예시

### 서브클래스가 하나일 때

'극'을 예약하는 서비스를 만든다 치자.

상속이 잘 들어맞고, 슈퍼클래스와 서브클래스가 각각의 특징을 가진다.

하지만 현실적이지 않다. 서브클래스 없이는 불완전한 요소가 있게 마련이다.
예를들어 일련의 큰 동작을 서브클래스에서 오버라이드 후 빈 곳을 메꾸도록 하는 메소드가 그것이다.
슈퍼클래스를 수정할 때 서브클래스까지 고려할 필요가 없는게 보통이지만, 그걸 모르고 건들였다가 서브클래스까지 망가지면 곤란하다.
이런 경우를 위해 서브클래스 고장까지 체크하는 테스트를 만들어두면 상속은 값어치를 한다.

상속은 딱 한 번만 선택할 수 있는 도구다. 상속을 사용해야 할 다른 이유가 생긴다면, 그리고 그 이유가 지금 구성한 서브클래스보다 더 가치있다 생각되면 다른 방식으로 과감히 바꿔야 할 것이다.
그리고 동적으로 클래스를 전환해야 한다거나, 다른 외부 요청으로 데이터를 받아온다거나, 데이터 구조가 바뀐다거나, 하는 등 프로그램의 근본적인 변화가 생기면 현재 구조는 매우 위태롭다.

그런 변화가 예상되면 서브클래스를 위임으로 바꾸는 편이 좋다.

1. 생성자를 팩토리 메소드로 바꿔서 생성자 호출부분을 캡슐화한다. 그리고 delegation용 클래스도 만든다.
2. 이 위임을 예약객체와 연결한다. 팩토리 함수를 바꿔서 Booking이 delegate를 포함하게 만든다.
3. 서브클래스의 `has_talk_back()` 을 빼고, 그걸 `Booking` 클래스에서 처리할 수 있게 처리한다. 이 내용이 두루뭉슬하게 적혀있어서 놓쳤는데, 8번스텝까지 하고 테스트를 돌리면 패스한다. <br />
7까지 수행하면 `PremiumBooking` 에 `has_talk_back()` 이 없으니 당연히 터진다.
4. 기본가격 메소드도 갈아치울텐데, 지금처럼 하면 무한재귀에 빠지므로 계산 로직을 함수로 추출(6.1절)한다. 아니면 확장 형태로 재호출하거나.
5. 서브클래스에만 존재하는 메소드도 위임으로 옮기고, 분배로직을 추가한다. <br />
존재하지 않는 객체에 접근하면 에러를 `raise` 하게 손봤다.
6. 테스트 해보고, 안쓰는 서브클래스를 지우고 또 테스트하고, 서브클래스를 지운다.

### 서브클래스가 여러개일때

그놈의 몬티파이썬 예제로 다시 보자.

- `EuropianSwallowDelegate` 처럼 쉬운거부터 하자.
- 어디서 위임필드를 초기화할지 정한다. 생성자가 받는 유일한 인수인 `data`에 필요정보가 모두 담겨져있으니 이 예시에선 생성자에서 처리한다. 위임을 여러개 만들어야하므로 타입코드 기반으로 올바른 위임을 선택하는 메소드도 만든다.
    - `data` 로 위임을 바로 할 수 있으니, 타입도 바로 체크해줄 수 있다.
    - 그걸 토대로 delegate 클래스에서 바로바로 처리가 가능하다.
- `AfricanSwallowDelegate` 도 쉬우니까 바로 넘어간다.
- `NorwegianBlueParrot` 의 경우, `plumage` 를 상속하고 있다
    - 이것도 단순히 `Bird`로 향하는 역참조만 추가해주면 쉽다.
    - 그러면 `SpeciesDelegate` 이라는 공통의 역참조 클래스를 꺼내서 여기다가 상속을 시키면 `plumage` 가 "다 들어있음"이 보장이된다.

이 코드의 장점은:
1. 위임으로 옮겨진 종 계층구조는 더 엄격하게 종만 관련된 내용만 다루게된다.
2. 위임 클래스에는 종에 따라 달라지는 데이터만 관리한다
3. 그와 상관없는 공통코드는 `Bird` 자체와 다른 서브클래스에 남는다.


[^1]: _Favor Object Composition over Class Inheritance._ 이 글도 읽어보면 좋다. [잘못 알려진 디자인 패턴의 두번째 원칙](https://architecture101.blog/2009/02/18/misconception_of_gof_dp/)
