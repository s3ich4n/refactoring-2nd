# 12.11 슈퍼클래스를 위임으로 바꾸기

_Replace Superclass with Delegate_

## 개요

Before

```python
class List:
    ...

class Stack(List):
    ...
```

After

```python
class List():
    ...

class Stack():
    def __init__(self):
        self._storage = List()
```

## 배경

객체지향 프로그래밍에서 상속은 기존 기능을 재활용하는 강력하고 손쉬운 수단이다.
필요하면 오버라이드 하거나 새 기능을 추가하면 되지만, 혼란과 복잡도를 쉽게 키울 수 있다.

그 대표적인 예시가 Java의 `Stack` 클래스다. 이는 `List` 를 상속하고 있는데, 데이터 저장/조작의 기능을 재활용하겠다는 생각이었다.
하지만 스택에 들어가면 안되는 연산마저 상속해버렸으니 모든 연산이 스택 인터페이스에 다 노출된다.
그런 이유로 자바의 `Stack` 은 슈퍼클래스를 위임으로 바꾸는 리팩터링에 대한 좋은 예시다.

제대로 된 상속이라면 서브클래스가 슈퍼클래스의 모든 기능을 사용함은 물론, 서브클래스의 인스턴스를 슈퍼클래스의 인스턴스로도 취급할 수 있어야 한다.
슈퍼클래스가 쓰이는 모든 곳에서 서브클래스의 인스턴스를 대신 사용해도 이상없이 동작해야한다.

예를 들어 이름과 엔진 크기 등을 속성으로 갖는 자동차 모델 클래스(타입)가 있다고 가정하자.
여기에 차량 식별번호, 제조일자 메소드를 더하면 물리 자동차(인스턴스)를 표현하는 데 재활용할 수 있다고 착각하는 것이다.
이것은 모델링 실수 중 하나로, 타입-인스턴스 동형이의어(_type-instance homonym_)[^1] 이라 하는 것이다.

이런 시그널이 보이면 상속 대신 위임으로 갈아타서 객체를 분리할 때라는 것이다. 위임을 이용하면 기능 일부만 빌려올 뿐, 서로 별개다 라는 것이 명확해진다.

서브클래스 방식의 모델링이 합리적일 때라도 슈퍼클래스를 위임으로 바꾸는 때가 있는데, 강결합을 분리하기 위함이다.
슈퍼클래스의 수정이 서브클래스로 이어지면 코드가 망가지기 쉽기 때문이다.
한편 위임에도 단점은 존재하는데, 위임의 기능을 이용할 호스트 함수 모두를 전달 함수(_forward function_)로 바꿔야한다. 문제가 발생할 여지는 적지만 꽤나 성가시다.

위 이유때문에 ***상속은 쓰면 안 된다*** 라고 하는데, 쓰면 안 된다기 보단 때에 맞게 쓰면 간단하고 효과적이다.
다만 상황이 변해서 상속이 좀 아쉬울 그 때, 리팩터링을 이용해서 슈퍼클래스를 위임으로 바꿀 수 있다.
마틴 파울러도 그런 이유로 인해 처음엔 상속을, 문제가 발생하면 위임을 바꾸라고 조언하는 것이다.

## 절차

1. 슈퍼클래스 객체를 참조하는 필드를 서브클래스에 만든다(이 리팩터링을 끝마치면 슈퍼클래스가 위임 객체로 변하므로, 이 필드는 '위임 참조' 로 일컫는다). 위임 참조를 새 슈퍼클래스 인스턴스로 초기화한다.
2. 슈퍼클래스 동작 각각에 대응하는 전달 함수를 서브클래스에 만든다(위임 참조로 전달). 서로 관련된 함수끼리 그룹으로 묶어 진행하며, 그룹을 하나씩 만들 때마다 테스트한다. <br />
→ 대부분은 전달함수 각각을 테스트할 수 있다. 하지만 getter/setter 쌍은 다 옮기고 나서야 테스트할 수 있다.
3. 슈퍼클래스 동작 모두가 전달 함수로 오버라이드 되면 상속관계를 끊는다.

## 예시

이 예시는 모델링 실수의 예시를 보여준다. 물리적 스크롤과 논리적 카탈로그 아이템에는 차이가 있기 때문이다.
석화병 치료를 적어놓은 스크롤은 사본이 여러 개임에도 카탈로그 아이템은 하나 뿐이다.

이런 오류는 대부분 해법이 있다. 지금 예시라면 제목과 태그로 사본을 구별할 수 있다.
데이터가 변하지 않으면 이런 대표성이 문제를 해결해줄 것이다.
하지만 사본 중 하나의 내용을 수정해야 한다면 같은 카테고리 항목의 다른 사본들 모두가 올바르게 수정되는 지 주의해서 확인해야한다.

이런 게 아니더라도 마틴 파울러는 이런 관계를 끊으려 할 것이다. 카탈로그 아이템을 스크롤의 슈퍼클래스로 사용하면 미래에 이 코드를 읽는 사람에게 혼란을 줄테니까.

### 예시 - 더 나아가서

카탈로그 아이템의 역할을 스크롤의 속성으로 옮겼다.
각각의 스크롤은 카탈로그 아이템의 '고유' 인스턴스를 하나씩 갖게되었는데, 더 나은 모델을 구성해보자.
도서관에 있는 사본 스크롤 여섯 개 모두 단 하나의 석화병 카탈로그 아이템을 참조하게 하자(값을 참조로 바꾸기, 9.5절).

이러려면 스크롤이 자신의 ID를 카탈로그 아이템의 ID필드에 저장했다.
카탈로그 아이템을 참조로 바꾸면 이 ID는 스크롤의 값이 아니라 해당 카탈로그 아이템의 ID로 바꿔야한다.
i.e., 스크롤은 카탈로그 아이템의 ID를 빌려쓰지 않고 자신의 ID 필드를 만들어야 한다.

[^1]: https://martinfowler.com/bliki/TypeInstanceHomonym.html