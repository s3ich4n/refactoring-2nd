# 12.1 메소드 올리기

_Pull Up Method_

## 개요

Before

```python
class Employee:
    ...

class SalesPerson(Employee):
    @property
    def name(self):
        return self._name

class Engineer(Employee):
    @property
    def name(self):
        return self._name
```

After

```python
class Employee:
    @property
    def name(self):
        return self._name

class SalesPerson(Employee):
    ...

class Engineer(Employee):
    ...
```

> [!TIP]
> 반대 리팩터링: 메소드 내리기 (12.4절)

## 배경

중복코드는 음쓰와 같다. 당장은 있어도 기분만 더러운데 나중엔 꼭 벌레가 꼬이고 냄새난다.
이런 코드는 일관성있는 변경이 전파되지 않는 위험을 항상 수반한다. 문제는 이런 중복코드를 찾기가 쉽지 않다는 점이다.

메소드 올리기를 적용하기 쉬운 상황은 메소드들의 본문 코드가 동일한 때이다. 이러면 복붙으로 끝이다.
이런 건 리팩터가 잘 되었나 검증하려면 테스트가 얼마나 이걸 잘 커버하는지가 중요하다. 그래서 차이점을 찾아내는게 효과가 좋다.
테스트에서 놓친 동작까지 알아야 하니까.

메소드 올리기를 하려면 선행단계를 거쳐야 한다. 서로 다른 두 클래스의 두 메소드를 각각 매개변수화하면 똑같은 메소드가 되기도 한다.
이런 경우라면 각각의 함수를 매개변수화(11.2절) 후 메소드를 상속계층의 위로 올리면 된다.

이번 기법이 적용되기에 가장 이상하고 복잡한 상황은 해당 메소드의 본문에서 참조하는 필드들이 서브클래스에만 있는 경우다.
이런 경우라면 필드들을 먼저 슈퍼클래스로 올리고(12.2절) 메소드를 올려야 한다.

두 메소드의 전체 흐름은 같지만 세부 내용이 다르면 템플릿 메소드 만들기[^1]도 고려해보자.

## 절차

1. 똑같이 동작하는 메소드인지 살펴본다.<br />
→ 실제로 하는 일은 같은데 코드만 다르면 본문 코드가 똑같아질 때 까지 리팩터링 한다 <br />
2. 메소드 안에서 호출하는 다른 메소드와 참조하는 필드들을 슈퍼클래스에서도 호출하고 참조할 수 있는지 확인한다.
3. 메소드 시그니처가 다르면 함수 선언 바꾸기(6.5절)로 슈퍼클래스에서 쓰고싶은 형태로 맞춘다
4. 슈퍼클래스에 새 메소드를 생성하고 대상 메소드의 코드를 복사한다
5. 정적 검사를 수행한다
6. 서브클래스 중 하나의 메소드를 제거한다
7. 테스트한다
8. 모든 서브클래스의 메소드가 없어질 때 까지 다른 서브클래스의 메소드를 하나씩 제거한다

## 예시

[^1] https://www.refactoring.com/catalog/formTemplateMethod.html