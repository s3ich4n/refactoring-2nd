# 6.6 변수 캡슐화하기

_Encapsulate Variable_

## 개요

Before

```python
default_owner = {"first_name": "Martin", "last_name": "Fowler"}
```

After

```python
class DefaultOwnerManager:
    def __init__(self):
        self._owner = {"first_name": "Martin", "last_name": "Fowler"}
    
    @property
    def owner(self):
        return self._owner.copy()
    
    @owner.setter
    def owner(self, new_owner):
        self._owner = new_owner

# usages
manager = DefaultOwnerManager()
print(manager.owner)  # getter 호출
manager.owner = {"first_name": "Kent", "last_name": "Beck"}  # setter 호출
```

## 배경

리팩터링은 프로그램의 요소를 조작하는 것이다. 함수는 데이터보다 다루기 수월하지만 데이터는 조금 까다롭다. 

데이터는 참조하는 부분을 한 덩어리로 두어야한다. 이 때 임시변수같은 건 수월하지만, 유효범위(scope?)가 넓어질 수록 다루기 어려워진다. 그래서 전역변수가 골치아픈 것이다.

이런 경우 그 데이터로의 접근을 독점하는 함수를 만들어 캡슐화하는 것이 필요하다.
데이터 재구성 대신 함수 재구성이란 어프로치로 시작하자. 

데이터 캡슐화는 데이터를 변경하고 사용하는 코드를 감시할 수 있게 된다. 이 때 검증, 추가로직을 쉽게 담을 수도 있다.
데이터의 유효범위가 넓을 수록 캡슐화가 더 필요하다. 레거시 코드를 다룰 때는 이런 변수를 참조하는 코드를 추가하거나, 최대한 캡슐화한다. 결합도를 낮추기 위함이다.
(마틴 파울러는 유효 범위가 함수 하나보다 넓은 가변 데이터를 이런 식으로 캡슐화한다고 한다)

이런 접근이 객체의 데이터를 `private` 으로 두어야 하자는 것이다. 가시범위를 좁히자는 의견은 나도 동의. 파이썬에선 파이썬스럽게, 다른 언어에선 가시범위를 최소한으로.

불변 데이터는 값을 바꿀 수도 없을 뿐더러, 필요하면 복사해서 쓰면 된다.

## 절차

1. 변수로의 접근과 갱신을 전담하는 캡슐화 함수를 만든다.
2. 정적 검사를 수행한다
3. 변수를 직접 참조하던 부분을 모두 적절한 캡슐화 호출로 바꾼다. 하나씩 바꿀 때마다 테스트한다.
4. 변수의 접근범위를 제한한다. <br />
→ 변수로의 직접접근을 막을 수 없을 때도 있다. 그럴 땐 변수이름을 바꿔서 테스트해보자. (원인을 찾기 위함)
5. 테스트한다
6. 변수값이 레코드라면 레코드 캡슐화하기(7.1절)을 고려해본다

## 예시

전역변수에 데이터가 담겨있고 그걸 get/set 할 수 있다고 가정하자.

위의 After 방법을 채택해서 처리했다.

### 캡슐화

그런데 캡슐화하고 싶으면? 값의 변경을 막는다거나...

예시와 비슷한 접근을 할 거면 불변객체를 쓰자.

웹 앱을 다룰 때나 프로젝트가 복잡해질때 이런 싱글턴 형식의 객체는 `dependency-injector`를 써서 처리하는게 좋을려나.

### 그런데!

이런 복제본, 클래스 감싸기는 레코드 구조 depth가 `1` 일 때만 효과가 있다. 더 깊게 들어가면 복제본, 객체 래핑이 많아진다.

캡슐화가 좋긴 하지만 과정이 쉽지않다. 따라서 그 구체적인 대상과 방법은 캡슐화를 할 데이터의 사용방식, 어떻게 변경할 것인지에 따라 다르다.

분명한 사실은 데이터의 사용범위가 넓을 수록 적절한 캡슐화는 꼭 필요하단 점이다.
