# 7.8 중재자 제거하기

_Remove Middle Man_

## 개요

Before

```python
manager = a_person.manager


class Person:
    @property
    def manager(self):
        return self.department.manager
```

After

```python
manager = a_person.department.manager
```

## 배경

위임 숨기기(7.7절)의 배경에서는 캡슐화의 이점을 설명했다.
다만 이러면 위임 객체의 다른 기능을 쓰려고 할 때마다 서버에 위임 메소드를 둬야한다.
이게 심해지면 서버 클래스는 중개자(_middle man_)으로 전락한다. 자꾸 이렇게 되면 클라이언트가 위임 객체를 직접 부르는게 낫다.

> [!WARNING]
>
> 이런 코드는 Law of Demeter 를 너무 신봉하면 생긴다.
> 내부정보를 과도하게 숨기면 wrapper가 늘어나는 단점이 생긴다.
>
> 상황에 맞게 사용하자!

답이 없다보니 7.7절과 7.8절을 계속 해가며 중간점을 찾아가면 된다.
시스템이 원하는 "적절한"시점은 그때그때 바뀌므로, 때에 맞추어 리팩터링하는 힘만 있으면 된다.

명심하자. 정답이 없다고 말하는 사람들은 "소프트웨어는 바뀜에 적응해야한다" 라는 말을 안하거나 할 필요가 없다고 해서 안한거다.

하지만 저게 중요하다. 소프트웨어 만드는 것은 답이 없다. 그럼 변화에 적응해야하는 힘을 길러야할 뿐...

## 절차

`<br />`, `→` 복사해서 쓰기

1. 위임 객체를 얻는 게터를 만든다
2. 위임 메소드를 호출하는 클라이언트가 모두 이 게터를 거치도록 수정한다. 하나씩 바꿀 때마다 테스트한다
3. 모두 수정했다면 위임 메소드를 삭제한다 <br />
   → 자동 리팩터링 도구를 쓸 때는 위임 필드를 캡슐화(6.6절)한 후 이를 사용하는 모든 메소드를 인라인(6.2절)한다

## 예시

자신이 속한 부서 객체를 통해 관리자를 찾는 사람 클래스이다만,

위임 메소드가 너무 많다 가정하고 중개자를 빼는 훈련을 해보자.
